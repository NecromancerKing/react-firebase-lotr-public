import {
  useCallback,
  useContext,
  useMemo,
  useState,
  useEffect,
  Ref
} from "react";

import { Checkbox, Icon } from "@react-gcc-eds/core";
import {
  ColDef,
  ICellRendererParams,
  ITooltipParams,
  ValueGetterParams
} from "ag-grid-community";
import { cloneDeep } from "lodash";

import EditableSingleSelectRenderer, {
  EditableSingleSelectRendererProps
} from "components/adapters/ag-grid/cells/ediable-select-renderer";
import EditableNumberRenderer, {
  EditableNumberRendererProps
} from "components/adapters/ag-grid/cells/editable-number-renderer";
import EditableTextAreaRenderer, {
  EditableTextAreaRendererProps
} from "components/adapters/ag-grid/cells/editable-textarea-renderer";
import EditableTextFieldRenderer, {
  EditableTextFieldRendererProps
} from "components/adapters/ag-grid/cells/editable-textfield-renderer";
import withAdvancedSetFilter from "components/adapters/ag-grid/columns/advanced-set-filter";
import {
  EdsAgGridHandle,
  TrackGridColumnsProps,
  TrackGridFiltersProps
} from "components/adapters/ag-grid/eds-ag-grid";
import { SingleSelectItem } from "components/adapters/react-gcc-eds/singleselect";
import { CustomerContext } from "global-contexts/customer/customer-context";
import {
  TEST_DATA_ATTRIBUTES,
  TEST_DATA_ATTRIBUTE_KEY,
  EDS_TEST_DATA_ATTRIBUTE_KEY
} from "testing-data-attributes";
import {
  BomSpecificKeys,
  GeneralKeys,
  NamespaceKeys
} from "translation/dictionary-keys";
import { useTranslation } from "translation/translation-utils";
import { ProductPackageType } from "utils/constants";

import {
  DeliveryProductListItemDto,
  JobViewModel,
  Role,
  SourcingModel
} from "../../../api/client";
import {
  ColumnHeaderTooltip,
  IPreviewBillOfMaterialItemDto,
  JobSplitterChanges
} from "../types/bom-specific-types";
import BomHeadersTooltip from "./bom-headers-tooltip";
import { BomItemIdentifier } from "./bom-item-identifiers";
import BomRequestContentViewer from "./bom-request-components/bom-request-content-viewer";
import useDictionary from "./bom-request-components/use-dictionary";
import { InfoTooltip, anyAdditionalInfoAvailable } from "./info-tooltip";

import "./bom-request-content.scss";

type Props = {
  items: IPreviewBillOfMaterialItemDto[];
  jobs: JobViewModel[];
  excludeNotes?: boolean;
  editable?: boolean;
  userCanEdit?: boolean;
  userCanSetQuoteFlag?: boolean;
  onItemChanged?: (
    item: IPreviewBillOfMaterialItemDto,
    callback?: (isChanged: boolean) => void
  ) => void;
  onItemDescriptionChanged?: (
    item: IPreviewBillOfMaterialItemDto,
    callback?: (isChanged: boolean) => void
  ) => void;
  onItemAdded?: (item: IPreviewBillOfMaterialItemDto) => void;
  onItemRemoved?: (item: IPreviewBillOfMaterialItemDto) => void;
  onItemRestored?: (item: IPreviewBillOfMaterialItemDto) => void;
  onMaterialCategorySplitterChange?: (
    newItems: IPreviewBillOfMaterialItemDto[],
    updatedItems: IPreviewBillOfMaterialItemDto[]
  ) => void;
  onServiceItemSplitterChange?: (
    newItems: IPreviewBillOfMaterialItemDto[],
    updatedItems: IPreviewBillOfMaterialItemDto[]
  ) => void;
  onJobSplitterChange?: (changes: JobSplitterChanges) => void;
  getTotalCount: (total: number) => void;
  handle: Ref<EdsAgGridHandle>;
  trackColumns?: TrackGridColumnsProps;
  trackFilters?: TrackGridFiltersProps;
};

type EditingDetailedDescriptionItem = {
  item: IPreviewBillOfMaterialItemDto;
  editing: boolean;
};

const BomContent = ({
  items,
  jobs,
  editable,
  userCanEdit,
  userCanSetQuoteFlag,
  getTotalCount,
  onItemChanged,
  onItemDescriptionChanged,
  onItemAdded,
  onItemRemoved,
  onItemRestored,
  handle,
  trackColumns,
  trackFilters
}: Props): React.ReactElement => {
  const { user } = useContext(CustomerContext);
  const { translate } = useTranslation();
  const originalItems: IPreviewBillOfMaterialItemDto[] = cloneDeep(items);
  const jobsById = useDictionary(jobs, "Id");

  const [editableDetailedDescription, setEditableDetailedDescription] =
    useState<EditingDetailedDescriptionItem[]>(
      items
        .filter((i) => !i.ExistsOnBom && i.IsServiceItem)
        .map((i) => ({
          item: i,
          editing: true
        }))
    );

  useEffect(() => {
    setEditableDetailedDescription((prev) => {
      const filteredItems = items
        .filter(
          (i) =>
            !i.ExistsOnBom &&
            i.IsServiceItem &&
            !prev
              .map((m) => m.item.DeliveryProductListItem?.Id)
              .includes(
                (i.DeliveryProductListItem as DeliveryProductListItemDto).Id
              )
        )
        .map((i) => ({
          item: i,
          editing: true
        }));
      return [...prev, ...filteredItems];
    });
  }, [items]);

  const dplItemExistsMoreThanOnce = useCallback(
    (dplItemId: string | undefined): boolean => {
      const allBomItemsWithSameDplItemId = items.filter(
        (bomItem) => bomItem.DeliveryProductListItem?.Id === dplItemId
      );
      return allBomItemsWithSameDplItemId.length > 1;
    },
    [items]
  );
  const productHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.ProductNumberHeaderName
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.ProductNumberDescription
      ),

      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.ExternalDpl)
    }),
    [translate]
  );
  const productNumberDuplicateInfo: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.ProductNumberDuplicateInfo
      )
    }),
    [translate]
  );
  const descriptiontHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.DescriptionTitle
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.DescriptionValue
      ),

      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.ExternalDpl)
    }),
    [translate]
  );
  const quantityHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.QuantityHeaderName
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.QuantityDescription
      ),

      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.Internal)
    }),
    [translate]
  );
  const deltaQuantityHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.DeltaQuantityHeaderName
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.DeltaQuantityDescription
      ),

      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.Internal)
    }),
    [translate]
  );

  const customerProductNumberHeaderTooltipContent: ColumnHeaderTooltip =
    useMemo(
      () => ({
        name: translate(
          NamespaceKeys.BomSpecific,
          BomSpecificKeys.CustomerProductNumberHeaderName
        ),
        description: translate(
          NamespaceKeys.BomSpecific,
          BomSpecificKeys.CustomerProductNumberDescription
        ),

        source: translate(
          NamespaceKeys.BomSpecific,
          BomSpecificKeys.ExternalDpl
        )
      }),
      [translate]
    );
  const fecProductHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.FecProductHeaderName
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.FecProductDescription
      ),

      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.ExternalDpl)
    }),
    [translate]
  );
  const uomHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.UoMHeaderName),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.UoMDescription
      ),

      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.ExternalDpl)
    }),
    [translate]
  );
  const materialCategoryHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.MaterialCategoryHeaderName
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.MaterialCategoryDescription
      ),

      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.ExternalDpl)
    }),
    [translate]
  );
  const commodityHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.CommodityHeaderName
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.CommodityDescription
      ),

      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.ExternalDpl)
    }),
    [translate]
  );
  const projectProviderHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.ProjectProviderHeaderName
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.ProjectProviderDescription
      ),

      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.ExternalDpl)
    }),
    [translate]
  );
  const detailedDescriptionHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.DetailedDescriptionHeaderName
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.DetailedDescription
      ),

      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.ExternalDpl)
    }),
    [translate]
  );
  const jobAssignmentHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.JobAssignmentHeaderName
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.JobAssignmentDescription
      )
    }),
    [translate]
  );
  const noteHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.NoteHeaderName
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.NoteDescription
      ),
      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.Internal)
    }),
    [translate]
  );
  const quoteHeaderTooltipContent: ColumnHeaderTooltip = useMemo(
    () => ({
      name: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.QuoteHeaderName
      ),
      description: translate(
        NamespaceKeys.BomSpecific,
        BomSpecificKeys.QuoteDescription
      ),
      source: translate(NamespaceKeys.BomSpecific, BomSpecificKeys.Internal)
    }),
    [translate]
  );
  const undo = useMemo<string>(
    () => translate(NamespaceKeys.General, GeneralKeys.Undo),
    [translate]
  );
  const noVendor = useMemo<string>(
    () => translate(NamespaceKeys.BomSpecific, BomSpecificKeys.NoVendor),
    [translate]
  );
  const notAssigned = useMemo<string>(
    () => translate(NamespaceKeys.BomSpecific, BomSpecificKeys.NotAssigned),
    [translate]
  );

  const renderDetailedDescription = useCallback(
    (
      cellInfo: ICellRendererParams<IPreviewBillOfMaterialItemDto>
    ): JSX.Element => {
      const itemIdentifier = new BomItemIdentifier(
        cellInfo.data as IPreviewBillOfMaterialItemDto
      );
      const itemToUpdate = editableDetailedDescription.find((other) =>
        itemIdentifier.equalToIdentifier(new BomItemIdentifier(other.item))
      );
      const editableTextField =
        EditableTextFieldRenderer<IPreviewBillOfMaterialItemDto>({
          setup: (cell): EditableTextFieldRendererProps => {
            return {
              isEditable:
                (editable &&
                  userCanEdit &&
                  !cell?.data?.ExistsOnBom &&
                  cell?.data?.IsServiceItem &&
                  itemToUpdate &&
                  itemToUpdate.editing) ??
                false,
              props: {
                className: "detailed-description-text-field"
              },
              suffixInside: true,
              icon: cell.value ? (
                <>
                  <Icon
                    name="cross"
                    onClick={() => cell.setValue && cell.setValue("")}
                  />
                  <Icon
                    name="check"
                    onClick={(e) => {
                      setEditableDetailedDescription((prev) => {
                        const updated = prev.map((i) => {
                          const id = new BomItemIdentifier(
                            cellInfo.data as IPreviewBillOfMaterialItemDto
                          );
                          const otherid = new BomItemIdentifier(
                            i.item ?? undefined
                          );

                          if (id.equalToIdentifier(otherid)) {
                            return {
                              item: i.item,
                              editing: false
                            };
                          }
                          return i;
                        });

                        return updated;
                      });
                      onItemDescriptionChanged &&
                        onItemDescriptionChanged(
                          {
                            ...(cellInfo.data as IPreviewBillOfMaterialItemDto),
                            DetailedDescription: cellInfo.value
                          },
                          (changed) => {
                            if (!changed) {
                              const originalItem = originalItems.find(
                                (o) =>
                                  o.DeliveryProductListItem?.Id ===
                                  (
                                    cellInfo.data as IPreviewBillOfMaterialItemDto
                                  ).DeliveryProductListItem?.Id
                              );
                              cellInfo.setValue &&
                                originalItem &&
                                cellInfo.setValue(
                                  originalItem.DetailedDescription
                                );
                            }
                          }
                        );
                      e.preventDefault();
                    }}
                  />
                </>
              ) : (
                <></>
              )
            };
          }
        });
      if (
        editable &&
        userCanEdit &&
        cellInfo.data?.IsServiceItem &&
        !cellInfo.data.ExistsOnBom
      )
        return itemToUpdate && itemToUpdate.editing ? (
          <>{editableTextField(cellInfo)}</>
        ) : (
          <>
            {cellInfo.value}
            <Icon
              name="plus"
              className="detailed-description-icon-plus"
              onClick={() => {
                onItemAdded &&
                  onItemAdded({
                    ...(cellInfo.data as IPreviewBillOfMaterialItemDto),
                    DetailedDescription: ""
                  });
                console.log("clicky! :)");
              }}
            ></Icon>
          </>
        );
      else return <>{cellInfo.value}</>;
    },
    [
      editable,
      userCanEdit,
      editableDetailedDescription,
      onItemDescriptionChanged,
      onItemAdded,
      originalItems
    ]
  );

  const renderProductNumberColumn = useCallback(
    (
      cellInfo: ICellRendererParams<IPreviewBillOfMaterialItemDto>
    ): JSX.Element | string => {
      return (
        <span
          className="product-number-cell"
          {...{
            [TEST_DATA_ATTRIBUTE_KEY]:
              TEST_DATA_ATTRIBUTES.BOMOverview.ProductNumberCell
          }}
        >
          {cellInfo?.value}
        </span>
      );
    },
    []
  );
  const isCrewLeaderOrSupplyResponsible = useMemo<boolean>(
    (): boolean =>
      user?.Role === Role.CrewLeader || user?.Role === Role.SupplyResponsible,
    [user?.Role]
  );

  const renderNumberQuantity = useMemo(() => {
    return EditableNumberRenderer<IPreviewBillOfMaterialItemDto>({
      setup: (cellInfo): EditableNumberRendererProps => {
        const typedRow = cellInfo?.data as IPreviewBillOfMaterialItemDto;
        return {
          isEditable: (editable && userCanEdit) ?? false,
          showTrashcanIcon: true,
          props: {
            dataAttributes: {
              [EDS_TEST_DATA_ATTRIBUTE_KEY]:
                TEST_DATA_ATTRIBUTES.BOMRequest.ManageQuantity
            },
            min:
              typedRow?.DeliveryProductListItem?.ProductPackageType !==
              ProductPackageType.NONE
                ? 0
                : 1,
            step:
              typedRow?.DeliveryProductListItem?.ProductPackageType !==
              ProductPackageType.NONE
                ? 0.01
                : 1,
            className: "quantity-number-field",
            onClick: () => {
              onItemRemoved &&
                onItemRemoved({
                  ...typedRow
                });
            },
            onBlur: (e: React.FocusEvent<HTMLInputElement, Element>) => {
              const newQuantity = Number(e?.target?.value);
              const originalItem = originalItems.find(
                (o) =>
                  o.DeliveryProductListItem?.Id ===
                  typedRow?.DeliveryProductListItem?.Id
              );
              const deltaQuantity =
                newQuantity -
                (originalItem?.Quantity ?? 0) +
                (originalItem?.DeltaQuantity ?? 0);

              newQuantity >= 0 &&
                onItemChanged &&
                onItemChanged(
                  {
                    ...typedRow,
                    Quantity: newQuantity,
                    DeltaQuantity: deltaQuantity,

                    DetailedDescription:
                      originalItem?.DetailedDescription ?? undefined
                  },
                  (changed) => {
                    if (!changed) {
                      const originalItem = originalItems.find(
                        (o) =>
                          o.DeliveryProductListItem?.Id ===
                          typedRow?.DeliveryProductListItem?.Id
                      );
                      cellInfo.setValue &&
                        originalItem &&
                        cellInfo.setValue(originalItem.Quantity);
                    }
                  }
                );
            }
          }
        };
      }
    });
  }, [editable, onItemChanged, onItemRemoved, originalItems, userCanEdit]);
  const renderSingleSelectQuantity = useMemo(
    () =>
      EditableSingleSelectRenderer<IPreviewBillOfMaterialItemDto, number>({
        setup: (cellInfo): EditableSingleSelectRendererProps<number> => {
          const typedRow = cellInfo?.data as IPreviewBillOfMaterialItemDto;

          const items =
            typedRow?.DeliveryProductListItem?.ValidQuantities?.map(
              (i): SingleSelectItem<number> => {
                return { title: i.toString(), value: i };
              }
            ) ?? [];
          return {
            isEditable: (editable && userCanEdit) ?? false,
            showTrashcanIcon: true,
            valuePicker: (newQuantity: SingleSelectItem<number>) => {
              newQuantity?.value &&
                newQuantity?.value &&
                onItemChanged &&
                onItemChanged({
                  ...typedRow,
                  Quantity: newQuantity.value,
                  DeltaQuantity:
                    newQuantity.value -
                    (typedRow?.Quantity ?? 0) +
                    typedRow?.DeltaQuantity,

                  DetailedDescription:
                    typedRow?.DetailedDescription ?? undefined
                });
              return newQuantity.value;
            },
            props: {
              items: items,
              className: "valid-quantities-single-select",
              onClick: () => {
                onItemRemoved &&
                  onItemRemoved({
                    ...typedRow
                  });
              }
            }
          };
        }
      }),
    [editable, onItemChanged, onItemRemoved, userCanEdit]
  );

  const renderDeltaQuantity = useCallback(
    (
      cellInfo: ICellRendererParams<IPreviewBillOfMaterialItemDto>
    ): JSX.Element | string => {
      const deltaQuantity =
        Math.round(((cellInfo.value as number) + Number.EPSILON) * 100) / 100;
      if (deltaQuantity === 0) {
        return <></>;
      }
      return (
        <div
          className={deltaQuantity > 0 ? "delta positive" : "delta negative"}
        >
          {deltaQuantity}
        </div>
      );
    },
    []
  );

  const renderSourcingProvider = useMemo(
    () =>
      EditableSingleSelectRenderer<IPreviewBillOfMaterialItemDto, string>({
        setup: (cellInfo): EditableSingleSelectRendererProps<string> => {
          const typedRow = cellInfo?.data as IPreviewBillOfMaterialItemDto;
          const items =
            typedRow?.DeliveryProductListItem?.Sourcings?.map(
              (i: SourcingModel): SingleSelectItem<string> => {
                return {
                  title: i?.SourcingProvider ?? "",
                  value: i?.SourcingProvider ?? ""
                };
              }
            ) ?? [];
          return {
            isEditable: (editable && userCanEdit) ?? false,
            valuePicker: (newItem: SingleSelectItem<string>) => {
              newItem?.value &&
                newItem?.value &&
                onItemChanged &&
                onItemChanged(
                  {
                    ...typedRow,
                    SourcingProvider: newItem.value
                  },
                  (changed) => {
                    if (!changed) {
                      const originalItem = originalItems.find(
                        (o) =>
                          o.DeliveryProductListItem?.Id ===
                          typedRow?.DeliveryProductListItem?.Id
                      );
                      cellInfo.setValue &&
                        originalItem &&
                        cellInfo.setValue(originalItem.SourcingProvider);
                    }
                  }
                );
              return newItem.value;
            },
            props: {
              items: items,
              className: "sourcing-provider-single-select",
              onClick: () => {
                onItemRemoved &&
                  onItemRemoved({
                    ...typedRow
                  });
              }
            }
          };
        }
      }),
    [editable, onItemChanged, onItemRemoved, originalItems, userCanEdit]
  );

  const renderJobs = useCallback(
    (params: ValueGetterParams<IPreviewBillOfMaterialItemDto>): string => {
      const item = params.data as IPreviewBillOfMaterialItemDto;

      if (!item?.IsServiceItem) return "";
      const job = item.JobId ? jobsById[item.JobId] : undefined;
      const textRepresentation = item?.JobId
        ? `${job?.Name} / ${
            job?.AssignedVendorAccountName ??
            job?.AssignedVendorAccountId ??
            noVendor
          }`
        : notAssigned;

      return textRepresentation;
    },
    [jobsById, noVendor, notAssigned]
  );

  const renderJobsTooltipValue = useCallback(
    (
      cellInfo: ITooltipParams<IPreviewBillOfMaterialItemDto>
    ): JSX.Element | string => {
      const item = cellInfo.data as IPreviewBillOfMaterialItemDto;
      if (!item?.IsServiceItem) return "";
      const job = item.JobId ? jobsById[item.JobId] : undefined;
      const textRepresentation = item?.JobId
        ? `${job?.Name} / ${
            job?.AssignedVendorAccountName ??
            job?.AssignedVendorAccountId ??
            noVendor
          }`
        : notAssigned;
      return textRepresentation;
    },
    [jobsById, noVendor, notAssigned]
  );
  const renderNote = useMemo(
    () =>
      EditableTextAreaRenderer<IPreviewBillOfMaterialItemDto>({
        setup: (cellInfo): EditableTextAreaRendererProps => {
          const item = cellInfo?.data as IPreviewBillOfMaterialItemDto;
          return {
            isEditable: (editable && userCanEdit) ?? false,
            props: {
              className: "note-text-area",
              onBlur: (e) => {
                onItemChanged &&
                  onItemChanged(
                    {
                      ...item,
                      Note: e?.target?.value
                    },
                    (changed) => {
                      if (!changed) {
                        const originalItem = originalItems.find(
                          (o) =>
                            o.DeliveryProductListItem?.Id ===
                            item?.DeliveryProductListItem?.Id
                        );
                        cellInfo.setValue &&
                          originalItem &&
                          cellInfo.setValue(originalItem.Note);
                      }
                    }
                  );
              }
            }
          };
        }
      }),
    [editable, onItemChanged, originalItems, userCanEdit]
  );

  const renderUndo = useCallback(
    (
      cellInfo: ICellRendererParams<IPreviewBillOfMaterialItemDto>
    ): JSX.Element => {
      const changed = cellInfo.value as boolean;
      const typedRow = cellInfo.data as IPreviewBillOfMaterialItemDto;

      return !changed ? (
        <></>
      ) : (
        <Icon
          name="restore"
          onClick={() => {
            onItemRestored && onItemRestored(typedRow);
          }}
        />
      );
    },
    [onItemRestored]
  );

  const toolTipValueGetter = (
    params: ITooltipParams<IPreviewBillOfMaterialItemDto>
  ) => ({ value: params.value });
  const defaultColDef = useMemo<ColDef<IPreviewBillOfMaterialItemDto>>(
    () => ({
      filter: true,
      filterParams: { buttons: ["reset"], suppressAndOrCondition: true },
      floatingFilter: true,
      sortable: true,
      unSortIcon: true,
      enableRowGroup: true,
      resizable: true,
      tooltipComponent: BomHeadersTooltip
    }),
    []
  );

  const handleOnChangeQuoteFlag = useCallback(
    (item: IPreviewBillOfMaterialItemDto, checked: boolean): void => {
      onItemChanged &&
        onItemChanged({
          ...item,
          Quote: checked
        });
    },
    [onItemChanged]
  );

  const initialColumnState = useMemo<
    ColDef<IPreviewBillOfMaterialItemDto>[]
  >(() => {
    const cols: ColDef<IPreviewBillOfMaterialItemDto>[] = [];
    cols.push(
      {
        filter: false,
        field: "PhaseOutDate",
        headerName: "Info",
        cellRenderer: (
          cellInfo: ICellRendererParams<IPreviewBillOfMaterialItemDto>
        ) => {
          const item = cellInfo.data?.DeliveryProductListItem;
          return item && anyAdditionalInfoAvailable(item, items) ? (
            <Icon name="message-contact-us" />
          ) : (
            ""
          );
        },
        valueGetter: (
          params: ValueGetterParams<IPreviewBillOfMaterialItemDto>
        ) => {
          return params?.data?.DeliveryProductListItem?.PhaseOutDate ?? "";
        },
        tooltipValueGetter: toolTipValueGetter,
        tooltipComponent: InfoTooltip,
        tooltipComponentParams: {
          bomItems: items
        },
        maxWidth: 100
      },
      {
        field: "EricssonProductNumber",
        headerName: productHeaderTooltipContent?.name,
        cellRenderer: renderProductNumberColumn,
        filter: "agTextColumnFilter",
        valueGetter: (
          params: ValueGetterParams<IPreviewBillOfMaterialItemDto>
        ) => {
          return params?.data?.DeliveryProductListItem?.EricssonProductNumber;
        },
        headerTooltip: productHeaderTooltipContent?.name,
        tooltipComponentParams: { content: productHeaderTooltipContent },
        tooltipValueGetter: (params: ITooltipParams) => {
          if (
            dplItemExistsMoreThanOnce(params?.data?.DeliveryProductListItem.Id)
          ) {
            return productNumberDuplicateInfo.name;
          } else {
            return params?.data?.DeliveryProductListItem?.EricssonProductNumber;
          }
        }
      },
      {
        field: "EricssonProductDescription",
        headerName: descriptiontHeaderTooltipContent.name,
        filter: "agTextColumnFilter",
        valueGetter: (
          params: ValueGetterParams<IPreviewBillOfMaterialItemDto>
        ) => {
          return params?.data?.DeliveryProductListItem
            ?.EricssonProductDescription;
        },
        minWidth: 200,
        headerTooltip: descriptiontHeaderTooltipContent.name,
        tooltipComponentParams: { content: descriptiontHeaderTooltipContent },
        tooltipValueGetter: (
          params: ITooltipParams<IPreviewBillOfMaterialItemDto>
        ) => params?.data?.DeliveryProductListItem?.EricssonProductDescription
      },
      {
        field: "Quantity",
        headerName: quantityHeaderTooltipContent.name,
        filter: "agNumberColumnFilter",
        cellRenderer: (
          cell: ICellRendererParams<IPreviewBillOfMaterialItemDto, number>
        ) => {
          return cell.data?.DeliveryProductListItem?.ValidQuantities?.length ??
            0 > 0
            ? renderSingleSelectQuantity(cell)
            : renderNumberQuantity(cell);
        },
        headerTooltip: quantityHeaderTooltipContent.name,
        tooltipComponentParams: { content: quantityHeaderTooltipContent },
        cellStyle: {
          overflow: editable ? "visible" : "hidden"
        },
        minWidth: 200,
        maxWidth: 200
      }
    );

    if (editable) {
      cols.push({
        field: "DeltaQuantity",
        headerName: deltaQuantityHeaderTooltipContent.name,
        valueGetter: (
          params: ValueGetterParams<IPreviewBillOfMaterialItemDto>
        ) => {
          return params?.data?.DeltaQuantity ?? 0;
        },
        cellRenderer: renderDeltaQuantity,
        minWidth: 90,
        headerTooltip: deltaQuantityHeaderTooltipContent.name,
        tooltipComponentParams: { content: deltaQuantityHeaderTooltipContent },
        tooltipValueGetter: (
          params: ITooltipParams<IPreviewBillOfMaterialItemDto>
        ) => params?.data?.DeltaQuantity
      });
    }
    cols.push(
      {
        field: "Quote",
        headerName: quoteHeaderTooltipContent.name,
        checkboxSelection: false,
        suppressAutoSize: true,
        suppressMenu: true,
        sortable: false,
        filter: false,
        headerTooltip: quoteHeaderTooltipContent.name,
        tooltipComponentParams: { content: quoteHeaderTooltipContent },
        cellRenderer: (
          cellInfo: ICellRendererParams<IPreviewBillOfMaterialItemDto>
        ) => {
          const item = cellInfo.data as IPreviewBillOfMaterialItemDto;

          const isDisabled =
            !Boolean(editable) ||
            !Boolean(userCanSetQuoteFlag) ||
            isCrewLeaderOrSupplyResponsible;

          return item && item.IsServiceItem ? (
            <div className={"grid-checkbox-cell"} id="quoteCheckbox">
              <Checkbox
                text=""
                checked={item.Quote ?? false}
                disabled={isDisabled}
                onChange={(checked: boolean) =>
                  handleOnChangeQuoteFlag(item, checked)
                }
                dataAttributes={{
                  [EDS_TEST_DATA_ATTRIBUTE_KEY]:
                    TEST_DATA_ATTRIBUTES.BOMOverview.QuoteFlag
                }}
              ></Checkbox>
            </div>
          ) : (
            ""
          );
        },
        maxWidth: 80
      },
      {
        field: "DetailedDescription",
        filter: "agTextColumnFilter",
        headerTooltip: detailedDescriptionHeaderTooltipContent.name,
        cellRenderer: renderDetailedDescription,
        minWidth: editable ? 220 : 100,
        cellStyle: { overflow: editable ? "visible" : "hidden" },
        tooltipComponentParams: {
          content: detailedDescriptionHeaderTooltipContent
        },
        tooltipValueGetter: (
          params: ITooltipParams<IPreviewBillOfMaterialItemDto>
        ) => params?.data?.DetailedDescription,
        valueGetter: (params) => params.data?.DetailedDescription ?? ""
      },
      {
        field: "JobId",
        headerName: jobAssignmentHeaderTooltipContent.name,
        filter: "agTextColumnFilter",
        valueGetter: renderJobs,
        headerTooltip: jobAssignmentHeaderTooltipContent.name,
        tooltipComponentParams: { content: jobAssignmentHeaderTooltipContent },
        tooltipValueGetter: renderJobsTooltipValue,
        minWidth: editable ? 240 : 100
      },
      {
        field: "CustomerProductNumber",
        headerName: customerProductNumberHeaderTooltipContent.name,
        valueGetter: (
          params: ValueGetterParams<IPreviewBillOfMaterialItemDto>
        ) => {
          return params?.data?.DeliveryProductListItem?.CustomerProductNumber;
        },
        filter: "agTextColumnFilter",
        headerTooltip: customerProductNumberHeaderTooltipContent.name,
        tooltipComponentParams: {
          content: customerProductNumberHeaderTooltipContent
        },
        tooltipValueGetter: (
          params: ITooltipParams<IPreviewBillOfMaterialItemDto>
        ) => params?.data?.DeliveryProductListItem?.CustomerProductNumber
      },
      {
        field: "FECProduct",
        valueGetter: (
          params: ValueGetterParams<IPreviewBillOfMaterialItemDto>
        ) => {
          return params?.data?.DeliveryProductListItem?.FecProduct;
        },
        filter: "agTextColumnFilter",
        headerTooltip: fecProductHeaderTooltipContent.name,
        tooltipComponentParams: { content: fecProductHeaderTooltipContent },
        tooltipValueGetter: (
          params: ITooltipParams<IPreviewBillOfMaterialItemDto>
        ) => params?.data?.DeliveryProductListItem?.FecProduct
      },
      {
        field: "UoM",
        headerName: uomHeaderTooltipContent.name,
        valueGetter: (
          params: ValueGetterParams<IPreviewBillOfMaterialItemDto>
        ) => {
          return params?.data?.DeliveryProductListItem?.UnitOfMeasurement;
        },
        filter: "agTextColumnFilter",
        headerTooltip: uomHeaderTooltipContent.name,
        tooltipComponentParams: { content: uomHeaderTooltipContent },
        tooltipValueGetter: (
          params: ITooltipParams<IPreviewBillOfMaterialItemDto>
        ) => params?.data?.DeliveryProductListItem?.UnitOfMeasurement
      },
      withAdvancedSetFilter({
        field: "MaterialCategory",
        headerTooltip: materialCategoryHeaderTooltipContent.name,
        tooltipComponentParams: {
          content: materialCategoryHeaderTooltipContent
        },
        tooltipValueGetter: (
          params: ITooltipParams<IPreviewBillOfMaterialItemDto>
        ) => params?.data?.MaterialCategory
      }),
      withAdvancedSetFilter({
        field: "Commodity",
        valueGetter: (
          params: ValueGetterParams<IPreviewBillOfMaterialItemDto>
        ) => {
          return params?.data?.DeliveryProductListItem?.Commodity;
        },
        headerTooltip: commodityHeaderTooltipContent.name,
        tooltipComponentParams: { content: commodityHeaderTooltipContent },
        tooltipValueGetter: (
          params: ITooltipParams<IPreviewBillOfMaterialItemDto>
        ) => params?.data?.DeliveryProductListItem?.Commodity
      }),
      {
        field: "SourcingProvider",
        headerName: projectProviderHeaderTooltipContent.name,
        filter: "agTextColumnFilter",
        cellRenderer: renderSourcingProvider,
        minWidth: editable ? 220 : 100,
        cellStyle: {
          overflow: editable ? "visible" : "hidden"
        },
        headerTooltip: projectProviderHeaderTooltipContent.name,
        tooltipComponentParams: {
          content: projectProviderHeaderTooltipContent
        },
        tooltipValueGetter: (
          params: ITooltipParams<IPreviewBillOfMaterialItemDto>
        ) => (!editable ? params?.data?.SourcingProvider : undefined)
      },

      {
        field: "Note",
        filter: "agTextColumnFilter",
        minWidth: editable ? 420 : 100,
        cellRenderer: renderNote,
        headerTooltip: noteHeaderTooltipContent.name,
        tooltipComponentParams: { content: noteHeaderTooltipContent },
        tooltipValueGetter: (
          params: ITooltipParams<IPreviewBillOfMaterialItemDto>
        ) => params?.data?.Note,
        valueGetter: (params) => params.data?.Note ?? ""
      }
    );
    if (editable && userCanEdit) {
      cols.push({
        field: "",
        headerName: "",
        filter: false,
        valueGetter: (
          params: ValueGetterParams<IPreviewBillOfMaterialItemDto>
        ) => {
          return params?.data?.Changed;
        },
        cellRenderer: renderUndo,
        tooltipValueGetter: ({ value }) => (value ? undo : ""),
        width: 70
      });
    }

    return cols;
  }, [
    commodityHeaderTooltipContent,
    customerProductNumberHeaderTooltipContent,
    deltaQuantityHeaderTooltipContent,
    descriptiontHeaderTooltipContent,
    detailedDescriptionHeaderTooltipContent,
    dplItemExistsMoreThanOnce,
    editable,
    fecProductHeaderTooltipContent,
    handleOnChangeQuoteFlag,
    isCrewLeaderOrSupplyResponsible,
    items,
    jobAssignmentHeaderTooltipContent,
    materialCategoryHeaderTooltipContent,
    noteHeaderTooltipContent,
    productHeaderTooltipContent,
    productNumberDuplicateInfo.name,
    projectProviderHeaderTooltipContent,
    quantityHeaderTooltipContent,
    renderDetailedDescription,
    quoteHeaderTooltipContent,
    renderDeltaQuantity,
    renderJobs,
    renderJobsTooltipValue,
    renderNote,
    renderNumberQuantity,
    renderProductNumberColumn,
    renderSingleSelectQuantity,
    renderSourcingProvider,
    renderUndo,
    undo,
    uomHeaderTooltipContent,
    userCanEdit,
    userCanSetQuoteFlag
  ]);

  const [columnDefs] =
    useState<ColDef<IPreviewBillOfMaterialItemDto>[]>(initialColumnState);

  return (
    <BomRequestContentViewer
      handle={handle}
      trackColumns={trackColumns}
      trackFilters={trackFilters}
      data={items}
      columnDefs={columnDefs}
      defaultColDef={defaultColDef}
      getTotalCount={getTotalCount}
    />
  );
};

export default BomContent;
